# stdlib
from enum import Enum
import os
from pathlib import Path
import platform
import tempfile
from typing import List

# third party
from packaging import version
import pydantic
import yaml

# relative
from ..types.base import SyftBaseModel
from ..util.util import get_root_data_path
from ..util.util import str_to_bool


class SupportedPythonVersions(Enum):
    MIN = "3.9"
    MAX = "3.11"


DOCKER_IGNORE_HEADER = """# generated by replicate/cog
__pycache__
*.pyc
*.pyo
*.pyd
.Python
env
pip-log.txt
pip-delete-this-directory.txt
.tox
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.log
.git
.mypy_cache
.pytest_cache
.hypothesis
"""


def dockerfile_store_path() -> Path:
    # data directory to store the generated dockerfile
    # on Linux and MacOS the directory is: ~/.syft/data/dockerfile/"
    # on Windows the directory is: C:/Users/$USER/.syft/data/dockerfile/

    data_dir: Path = get_root_data_path()
    dockerfile_path = data_dir + "/dockerfile"
    dockerfile_path.mkdir(parents=True, exist_ok=True)

    return dockerfile_path


class DockerConfig(SyftBaseModel):
    """
    build:
      python_version: "3.11"
      python_packages:
        - pytorch==2.0.1
      system_packages:
        - "ffmpeg"
        - "libavcodec-dev"
    """

    gpu: bool = False
    python_version: str = "3.11"
    python_packages: List[str] = []
    system_packages: List[str] = []
    run_cmds: List[str] = []

    @pydantic.validator("python_version")
    def validate_python_version(cls, v: str):
        python_version = version.parse(v)
        print("python_version", python_version)
        valid_version = python_version >= version.parse(
            SupportedPythonVersions.MIN.value
        ) and python_version <= version.parse(SupportedPythonVersions.MAX.value)
        if not valid_version:
            raise ValueError(
                f"Python version should be in "
                f"[>={SupportedPythonVersions.MIN.value}, <={SupportedPythonVersions.MAX.value}]"
            )
        return v

    @classmethod
    def from_yaml_str(cls, config_string):
        config = yaml.safe_load(config_string)
        return cls(**config["build"])

    @classmethod
    def from_yaml_file(cls, fp: str):
        file_path = Path(fp)
        config = yaml.safe_load(file_path.read_text())
        return cls(**config["build"])


class DockerFileGenerator:
    def __init__(
        self,
        config: DockerConfig,
        directory: Path,
    ) -> None:
        self.config = config
        self.directory = directory
        self.OS = os.name
        self.ARCH = platform.architecture()[0]
        self.use_cuda_base_image = False
        self.tmp_dir = tempfile.mkdtemp()
        self.relative_tmp_dir = os.path.relpath(self.tmp_dir, directory)

    def set_user_cuda_base_image(self, use_cuda: str):
        self.use_cuda_base_image = str_to_bool(use_cuda)

    def set_args(self):
        default_args = """ARG TZ="Etc/UTC"
        # change to USER="syftuser", UID=1000 and HOME="/home/$USER" for rootless \
        ARG USER="root"
        ARG UID=0
        ARG USER_GRP=$USER:$USER
        ARG HOME="/root"
        ARG APPDIR="$HOME/app" """
        return default_args

    def pip_install_stage(self):
        pass

    def set_base_image(self):
        return """ARG BASE_IMAGE="openmined/grid-backend" """

    def install_python(self):
        return f"""ARG PYTHON_VERSION="{self.config.python_version}" """

    def pip_installs(self):
        packages_list = " ".join(
            [package.strip() for package in self.config.python_packages]
        )

        cmd = f"""ARG APPDIR
        ARG HOME
        ARG UID
        ARG USER
        ARG USER_GRP

        USER $USER
        WORKDIR $APPDIR
        ENV PATH=$PATH:$HOME/.local/bin

        # Install all dependencies together here to avoid any version conflicts across pkgs
        RUN --mount=type=cache,target=$HOME/.cache/,rw,uid=$UID \
        pip install --user pip-autoremove {packages_list}
        """
        return cmd

    def set_apk_installs(self):
        apk_installs_str = " ".join(
            [package.strip() for package in self.config.system_packages]
        )
        command = (
            f"""RUN apk update && \
                apk add {apk_installs_str}"""
            if apk_installs_str
            else ""
        )
        return command

    def set_run_commands(self):
        cmds = []
        for cmd in self.config.run_cmds:
            cmd = cmd.strip()
            cmds += f"RUN {cmd}"

        return "\n".join(cmds)

    def generate_image(self):
        base_image = self.set_base_image()
        set_default_args = self.set_args()
        install_python = self.install_python()
        apk_installs = self.set_apk_installs()
        run_commands = self.set_run_commands()

        return "\n".join(
            self.filter_empty(
                [
                    "# syntax=docker/dockerfile:1.4",
                    set_default_args,
                    base_image,
                    "FROM $BASE_IMAGE as syft-base",
                    install_python,
                    apk_installs,
                    self.pip_installs(),
                    run_commands,
                    "WORKDIR /src",
                ]
            )
        )

    def filter_empty(self, lst):
        return [item for item in lst if item]
